dplyr::filter(year >= max(year)-6, measure == "Household") |>   # Select the 6 most recent year spans
dplyr::mutate(#Passed into ggplot (PDF Plot) but displayed in plotly (HMTL Plot)
toolTipTextHeader1 = "Year: "
, toolTipTextValue1 = year
, toolTipTextHeader2 = "\nLocation: "
, toolTipTextValue2 = location
, toolTipTextHeader3 = "\nHousehold Visits: "
, toolTipTextValue3 = scales::label_comma(accuracy = 0.01)(rawValue)
)
minYr <- unique(min(filtered_data$year))
maxYr <- unique(max(filtered_data$year))
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(rawValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageDifference = dplyr::case_when(
year == maxYr ~ (rawValue[year == maxYr] - rawValue[year == minYr])
/ rawValue[year == minYr]
, TRUE ~ ""
)
, percentageDifference = ifelse(is.na(percentageDifference), "--", scales::label_percent(accuracy = .01)(percentageDifference))
) |>
dplyr::ungroup() |>
dplyr::select(year, location, placeholder, percentageDifference) # Ensure fields are ordered as desired.
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(rawValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageDifference = dplyr::case_when(
year == maxYr ~ (rawValue[year == maxYr] - rawValue[year == minYr])
/ rawValue[year == minYr]
, TRUE ~ ""
)
, percentageDifference = ifelse(is.na(percentageDifference), "--", scales::label_percent(accuracy = .01)(percentageDifference))
)
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(rawValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageDifference = dplyr::case_when(
year == maxYr ~ (rawValue[year == maxYr] - rawValue[year == minYr])
/ rawValue[year == minYr]
, TRUE ~ ""
)
# , percentageDifference = ifelse(is.na(percentageDifference), "--", scales::label_percent(accuracy = .01)(percentageDifference))
)
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(rawValue)) |>
dplyr::group_by(fips)
filtered_dataTbl
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(rawValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageDifference = dplyr::case_when(
year == maxYr ~ maxYr ~ (dplyr::last(rawValue) - dplyr::first(rawValue)) / dplyr::first(rawValue)
, TRUE ~ ""
)
# , percentageDifference = ifelse(is.na(percentageDifference), "--", scales::label_percent(accuracy = .01)(percentageDifference))
)
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(rawValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageDifference = dplyr::case_when(
year == maxYr ~ maxYr ~ (dplyr::last(rawValue) - dplyr::first(rawValue)) / dplyr::first(rawValue)
, TRUE ~ NA_real_
)
# , percentageDifference = ifelse(is.na(percentageDifference), "--", scales::label_percent(accuracy = .01)(percentageDifference))
)
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(rawValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageDifference = dplyr::case_when(
year == maxYr ~ (dplyr::last(rawValue) - dplyr::first(rawValue)) / dplyr::first(rawValue)
, TRUE ~ NA_real_
)
# , percentageDifference = ifelse(is.na(percentageDifference), "--", scales::label_percent(accuracy = .01)(percentageDifference))
)
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(rawValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageDifference = dplyr::case_when(
year == maxYr ~ (dplyr::last(rawValue) - dplyr::first(rawValue)) / dplyr::first(rawValue)
, TRUE ~ ""
)
# , percentageDifference = ifelse(is.na(percentageDifference), "--", scales::label_percent(accuracy = .01)(percentageDifference))
)
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(rawValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageDifference = dplyr::case_when(
year == maxYr ~ maxYr ~ (dplyr::last(rawValue) - dplyr::first(rawValue)) / dplyr::first(rawValue)
, TRUE ~ NA_real_
)
# , percentageDifference = ifelse(is.na(percentageDifference), "--", scales::label_percent(accuracy = .01)(percentageDifference))
)
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(rawValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageDifference = dplyr::case_when(
year == maxYr ~ (rawValue[year == maxYr] - rawValue[year == minYr])
/ rawValue[year == minYr]
, TRUE ~ NA_real_
)
# , percentageDifference = ifelse(is.na(percentageDifference), "--", scales::label_percent(accuracy = .01)(percentageDifference))
)
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(rawValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageDifference = dplyr::case_when(
year == maxYr ~ (dplyr::last(rawValue) - dplyr::first(rawValue)) / dplyr::first(rawValue)
, TRUE ~ NA_real_
)
# , percentageDifference = ifelse(is.na(percentageDifference), "--", scales::label_percent(accuracy = .01)(percentageDifference))
)
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(rawValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageDifference = dplyr::case_when(
year == maxYr ~ (dplyr::last(rawValue) - dplyr::first(rawValue)) / dplyr::first(rawValue)
, TRUE ~ NA_real_
)
, percentageDifference = ifelse(is.na(percentageDifference), "--", scales::label_percent(accuracy = .01)(percentageDifference))
)
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(rawValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageDifference = dplyr::case_when(
year == maxYr ~ (dplyr::last(rawValue) - dplyr::first(rawValue)) / dplyr::first(rawValue)
, TRUE ~ NA_real_
)
, percentageDifference = ifelse(is.na(percentageDifference), "--", scales::label_percent(accuracy = .01)(percentageDifference))
) |>
dplyr::ungroup() |>
dplyr::select(year, location, placeholder, percentageDifference) # Ensure fields are ordered as desired.
filtered_dataTbl
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_comma(accuracy = .01)(rawValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageDifference = dplyr::case_when(
year == maxYr ~ (dplyr::last(rawValue) - dplyr::first(rawValue)) / dplyr::first(rawValue)
, TRUE ~ NA_real_
)
, percentageDifference = ifelse(is.na(percentageDifference), "--", scales::label_percent(accuracy = .01)(percentageDifference))
) |>
dplyr::ungroup() |>
dplyr::select(year, location, placeholder, percentageDifference) # Ensure fields are ordered as desired.
filtered_dataTbl
#| warning: false
#| include: false
# Data Wrangling so it can just be referenced in the PDF and HTML output instead of writing it twice
filtered_data <- f_kidsCountMotherSmoke |>
dplyr::filter(year >= max(year)-6) |>   # Select the 6 most recent year spans
dplyr::mutate(#Passed into ggplot (PDF Plot) but displayed in plotly (HMTL Plot)
toolTipTextHeader1 = "Year: "
, toolTipTextValue1 = year
, toolTipTextHeader2 = "\nLocation: "
, toolTipTextValue2 = location
, toolTipTextHeader3 = "\nPercentage: "
, toolTipTextValue3 = scales::label_percent(accuracy = 0.01)(dataValue)
)
minYr <- unique(min(filtered_data$year))
maxYr <- unique(max(filtered_data$year))
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(dataValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageChange = dplyr::case_when(
year == maxYr ~ scales::label_percent(accuracy = .01)((dataValue) - dplyr::first(dataValue)) #Since there is only 2, most recent - next
, TRUE ~ ""
)
, percentageChange = ifelse(is.na(percentageChange), "--", percentageChange)
) |>
dplyr::ungroup() |>
dplyr::select(year, location, placeholder, percentageChange) # Ensure fields are ordered as desired.
figCap_plotTitle <- " Percentage of Mothers Who Smoked During Pregnancy"
figSubcap <- "Data Source: @kidsCountMothersWhoSmoked"
plotXCaption <- paste("Data Source:",kidsCountMothersWhoSmoked) #Since the x axis is passed into plotly, I am defining the x axis for the plot with the data source so when/if people use the plot in their work the data source is referenced ggplot does a a caption argument but it does not pass into plotly. If the caption should be after the legend, then ggplot caption can be used for the pdf version and annotation can be used in plotly, I'll just have to pass an extra argument into the plotly function.
# Plot
scaleYContinuous = scales::label_percent()
#Table
colList <- list("Year", "Location", "Mothers Who Smoked", "% Change") # Using a list accommodates tables with different column lengths.
#Define the plot here so it is only wrote once
p <- gbFun_plotTrendPDF(
filtered_data, "year", "dataValue", "location", "fips", "toolTipTextHeader1",
"toolTipTextValue1", "toolTipTextHeader2", "toolTipTextValue2", "toolTipTextHeader3",
"toolTipTextValue3", figCap_plotTitle, plotXCaption, "", minYr, maxYr,
scaleYContinuous, gbVal_colorScheme, gbVal_shapeScheme, ifelse(knitr::is_html_output(), 10, 14)
)
#| fig-width: 8
#| fig-height: 5
#| warning: false
if (knitr::is_html_output()) {
# Create the ggplot plot ggplot and then its wrapped within plotly function
gbFun_plotHTML(p, figCap_plotTitle)
}
#| tbl-width: 8
#| tbl-height: 4
#| warning: false
if (knitr::is_html_output()) {
gbFun_tableHTML(filtered_dataTbl, colList, figCap_plotTitle)
}
#| warning: false
#| include: false
# Filter the data by 'measureid'
filtered_data <- f_places2022 |>
dplyr::filter(measureid == "CSMOKING") |>
dplyr::mutate(#Passed into ggplot (PDF Plot) but displayed in plotly (HMTL Plot)
toolTipTextHeader1 = "\nLocation: "
, toolTipTextValue1 = locationname
, toolTipTextHeader2 = "\nPrevalence: "
, toolTipTextValue2 = paste0(formattable::comma(data_value,0), " (", formattable::comma(low_confidence_limit,0), "-", formattable::comma(high_confidence_limit,0), ")")
)
filtered_ageAdjustedTbl <- filtered_data |>
dplyr::filter(datavaluetypeid == "AgeAdjPrv") |>
dplyr::arrange(locationid, year) |>
dplyr::mutate(PrevalenceType = "Age-Adjusted") |>
dplyr::select(PrevalenceType, locationname, low_confidence_limit, data_value, high_confidence_limit)
filtered_crudeTbl <- filtered_data |>
dplyr::filter(datavaluetypeid == "CrdPrv") |>
dplyr::arrange(locationid, year) |>
dplyr::mutate(PrevalenceType = "Crude") |>
dplyr::select(PrevalenceType, locationname, low_confidence_limit, data_value, high_confidence_limit)
figCap_plotTitle <- paste(filtered_data$measure[1], filtered_data$brfssYr[1])
figSubcap <- "Data Source: @cdc2024Places"
plotXCaption <- paste("Data Source:",cdc2024Places) #Since the x axis is passed into plotly, I am defining the x axis for the plot with the data source so when/if people use the plot in their work the data source is referenced ggplot does a a caption argument but it does not pass into plotly. If the caption should be after the legend, then ggplot caption can be used for the pdf version and annotation can be used in plotly, I'll just have to pass an extra argument into the plotly function.
#Table
colList <- list("Type", "Location", "Low CI", "Prevalence", "High CI") # Using a list accommodates tables with different column lengths.
#Define the plot here so it is only wrote once
p <- gbFun_plotSingleYrPDF(filtered_data, "locationname", "locationid","data_value", "toolTipTextHeader1",
"toolTipTextValue1", "toolTipTextHeader2", "toolTipTextValue2", "data_value_type",
"low_confidence_limit", "high_confidence_limit", figCap_plotTitle, plotXCaption, "Prevalence",
gbVal_colorScheme, ifelse(knitr::is_html_output(), 10, 12)
)
#| warning: false
#| include: false
# Data Wrangling so it can just be referenced in the PDF and HTML output instead of writing it twice
filtered_data <- f_kidsCountMotherSmoke |>
dplyr::filter(year >= max(year)-6) |>   # Select the 6 most recent year spans
dplyr::mutate(#Passed into ggplot (PDF Plot) but displayed in plotly (HMTL Plot)
toolTipTextHeader1 = "Year: "
, toolTipTextValue1 = year
, toolTipTextHeader2 = "\nLocation: "
, toolTipTextValue2 = location
, toolTipTextHeader3 = "\nPercentage: "
, toolTipTextValue3 = scales::label_percent(accuracy = 0.01)(dataValue)
)
minYr <- unique(min(filtered_data$year))
maxYr <- unique(max(filtered_data$year))
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy = .01)(dataValue)) |>
dplyr::group_by(fips) |>
dplyr::mutate(percentageChange = dplyr::case_when(
year == maxYr ~ scales::label_percent(accuracy = .01)((dataValue) - dplyr::first(dataValue)) #Since there is only 2, most recent - next
, TRUE ~ ""
)
, percentageChange = ifelse(is.na(percentageChange), "--", percentageChange)
) |>
dplyr::ungroup() |>
dplyr::select(year, location, placeholder, percentageChange) # Ensure fields are ordered as desired.
figCap_plotTitle <- " Percentage of Mothers Who Smoked During Pregnancy"
figSubcap <- "Data Source: @kidsCountMothersWhoSmoked"
plotXCaption <- paste("Data Source:",kidsCountMothersWhoSmoked) #Since the x axis is passed into plotly, I am defining the x axis for the plot with the data source so when/if people use the plot in their work the data source is referenced ggplot does a a caption argument but it does not pass into plotly. If the caption should be after the legend, then ggplot caption can be used for the pdf version and annotation can be used in plotly, I'll just have to pass an extra argument into the plotly function.
# Plot
scaleYContinuous = scales::label_percent()
#Table
colList <- list("Year", "Location", "Mothers Who Smoked", "% Change") # Using a list accommodates tables with different column lengths.
#Define the plot here so it is only wrote once
p <- gbFun_plotTrendPDF(
filtered_data, "year", "dataValue", "location", "fips", "toolTipTextHeader1",
"toolTipTextValue1", "toolTipTextHeader2", "toolTipTextValue2", "toolTipTextHeader3",
"toolTipTextValue3", figCap_plotTitle, plotXCaption, "", minYr, maxYr,
scaleYContinuous, gbVal_colorScheme, gbVal_shapeScheme, ifelse(knitr::is_html_output(), 10, 14)
)
#| fig-width: 8
#| fig-height: 5
#| warning: false
if (knitr::is_html_output()) {
# Create the ggplot plot ggplot and then its wrapped within plotly function
gbFun_plotHTML(p, figCap_plotTitle)
}
#| tbl-width: 8
#| tbl-height: 4
#| warning: false
if (knitr::is_html_output()) {
gbFun_tableHTML(filtered_dataTbl, colList, figCap_plotTitle)
}
#| warning: false
#| include: false
# Filter the data by 'measureid'
filtered_data <- f_places2022 |>
dplyr::filter(measureid == "CSMOKING") |>
dplyr::mutate(#Passed into ggplot (PDF Plot) but displayed in plotly (HMTL Plot)
toolTipTextHeader1 = "\nLocation: "
, toolTipTextValue1 = locationname
, toolTipTextHeader2 = "\nPrevalence: "
, toolTipTextValue2 = paste0(formattable::comma(data_value,0), " (", formattable::comma(low_confidence_limit,0), "-", formattable::comma(high_confidence_limit,0), ")")
)
filtered_ageAdjustedTbl <- filtered_data |>
dplyr::filter(datavaluetypeid == "AgeAdjPrv") |>
dplyr::arrange(locationid, year) |>
dplyr::mutate(PrevalenceType = "Age-Adjusted") |>
dplyr::select(PrevalenceType, locationname, low_confidence_limit, data_value, high_confidence_limit)
filtered_crudeTbl <- filtered_data |>
dplyr::filter(datavaluetypeid == "CrdPrv") |>
dplyr::arrange(locationid, year) |>
dplyr::mutate(PrevalenceType = "Crude") |>
dplyr::select(PrevalenceType, locationname, low_confidence_limit, data_value, high_confidence_limit)
figCap_plotTitle <- paste(filtered_data$measure[1], filtered_data$brfssYr[1])
figSubcap <- "Data Source: @cdc2024Places"
plotXCaption <- paste("Data Source:",cdc2024Places) #Since the x axis is passed into plotly, I am defining the x axis for the plot with the data source so when/if people use the plot in their work the data source is referenced ggplot does a a caption argument but it does not pass into plotly. If the caption should be after the legend, then ggplot caption can be used for the pdf version and annotation can be used in plotly, I'll just have to pass an extra argument into the plotly function.
#Table
colList <- list("Type", "Location", "Low CI", "Prevalence", "High CI") # Using a list accommodates tables with different column lengths.
#Define the plot here so it is only wrote once
p <- gbFun_plotSingleYrPDF(filtered_data, "locationname", "locationid","data_value", "toolTipTextHeader1",
"toolTipTextValue1", "toolTipTextHeader2", "toolTipTextValue2", "data_value_type",
"low_confidence_limit", "high_confidence_limit", figCap_plotTitle, plotXCaption, "Prevalence",
gbVal_colorScheme, ifelse(knitr::is_html_output(), 10, 12)
)
#| fig-width: 8
#| fig-height: 5
if (knitr::is_html_output()) {
# Create the ggplot plot ggplot and then its wrapped within plotly function
gbFun_plotHTML(p)
}
#| fig-width: 8
#| fig-height: 4
#| warning: false
if (knitr::is_html_output()) {
#Tables shouldn't be printed because the HTML table will display
gbFun_tableHTML(filtered_ageAdjustedTbl, colList, figCap_plotTitle)
}
#| fig-width: 8
#| fig-height: 4
#| warning: false
if (knitr::is_html_output()) {
#Tables shouldn't be printed because the HTML table will display
gbFun_tableHTML(filtered_crudeTbl, colList, figCap_plotTitle)
}
#| warning: false
#| include: false
# Data Wrangling so it can just be referenced in the PDF and HTML output instead of writing it twice
filtered_data <- f_pHDAPImmunization |>
dplyr::filter(vaccine == "Seven vaccine series")
dplyr::group_by(location, fips) |>
dplyr::mutate(#Passed into ggplot (PDF Plot) but displayed in plotly (HMTL Plot)
toolTipTextHeader1 = "Year: "
, toolTipTextValue1 = year
, toolTipTextHeader2 = "\nLocation: "
, toolTipTextValue2 = location
, toolTipTextHeader3 = "\nSeven Series Vaccine Percentage: "
, toolTipTextValue3 = scales::label_percent(accuracy= 0.01)(percent)
) |>
dplyr::ungroup()
#| warning: false
#| include: false
# Data Wrangling so it can just be referenced in the PDF and HTML output instead of writing it twice
filtered_data <- f_pHDAPImmunization |>
dplyr::filter(vaccine %in%c("DTap", "Hep A", "Hep B", "Hib", "MMR" )) |>
dplyr::group_by(location, fips) |>
dplyr::mutate(#Passed into ggplot (PDF Plot) but displayed in plotly (HMTL Plot)
toolTipTextHeader1 = "Year: "
, toolTipTextValue1 = year
, toolTipTextHeader2 = "\nLocation: "
, toolTipTextValue2 = location
, toolTipTextHeader3 = "\nVaccine Percentage: "
, toolTipTextValue3 = scales::label_percent(accuracy= 0.01)(percent)
) |>
dplyr::ungroup()
minYr <- unique(min(filtered_data$year))
maxYr <- unique(max(filtered_data$year))
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, vaccine, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy= 0.01)(percent)) |>  #I wanted to use formattable but DT strips format when converted to HTML Table
dplyr::group_by(fips) |>
dplyr::mutate(percentageChange = dplyr::case_when(
year == maxYr ~ scales::label_percent(accuracy= 0.01)((percent) - dplyr::first(percent)) #Since there is only 2, most recent - next
, TRUE ~ ""
)
, percentageChange = ifelse(is.na(percentageChange), "--", percentageChange)
) |>
dplyr::ungroup() |>
dplyr::select(year, location, vaccine, placeholder, percentageChange) # Ensure fields are ordered as desired.
#split table into two groups for pdf output
filtered_dataTblMM <- filtered_dataTbl |>
dplyr::filter(location %in% c("Minnesota", "Manhomen"))  # two locations
filtered_dataTblNP <- filtered_dataTbl |>
dplyr::filter(location %in% c("Norman", "Polk")) #split table into two groups with two locations
figCap_plotTitle <- "Percentage of Polk, Norman, Manhomen County\nChildren Ages 24−35 Months for DTap, Hep A, Hep B, Hib, & MMR"
figSubcap <- "Data Source: @mdhPHDAPImmuizations"
plotXCaption <- paste("Data Source:",mdhPHDAPImmuizations) #Since the x axis is passed into plotly, I am defining the x axis for the plot with the data source so when/if people use the plot in their work the data source is referenced ggplot does a a caption argument but it does not pass into plotly. If the caption should be after the legend, then ggplot caption can be used for the pdf version and annotation can be used in plotly, I'll just have to pass an extra argument into the plotly function.
rm()
cl
cl()
clear()
#| warning: false
#| include: false
# Data Wrangling so it can just be referenced in the PDF and HTML output instead of writing it twice
filtered_data <- f_pHDAPImmunization |>
dplyr::filter(vaccine %in% c(vaccine %in% c("PCV", "Polio", "Rotavirus", "Varicella"))) |>
dplyr::group_by(location, fips) |>
dplyr::mutate(#Passed into ggplot (PDF Plot) but displayed in plotly (HMTL Plot)
toolTipTextHeader1 = "Year: "
, toolTipTextValue1 = year
, toolTipTextHeader2 = "\nLocation: "
, toolTipTextValue2 = location
, toolTipTextHeader3 = "\nVaccine Percentage: "
, toolTipTextValue3 = scales::label_percent(accuracy= 0.01)(percent)
) |>
dplyr::ungroup()
minYr <- unique(min(filtered_data$year))
maxYr <- unique(max(filtered_data$year))
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, vaccine, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy= 0.01)(percent)) |>  #I wanted to use formattable but DT strips format when converted to HTML Table
dplyr::group_by(fips, vaccine) |>
dplyr::mutate(percentageChange = dplyr::case_when(
year == maxYr ~ scales::label_percent(accuracy= 0.01)((percent) - dplyr::first(percent)) #Since there is only 2, most recent - next
, TRUE ~ ""
)
, percentageChange = ifelse(is.na(percentageChange), "--", percentageChange)
) |>
dplyr::ungroup() |>
dplyr::select(year, location, vaccine, placeholder, percentageChange) # Ensure fields are ordered as desired.
#split table into two groups for pdf output
filtered_dataTblMM <- filtered_dataTbl |>
dplyr::filter(location %in% c("Minnesota", "Mahnomen"))  # two locations
filtered_dataTblNP <- filtered_dataTbl |>
dplyr::filter(location %in% c("Norman", "Polk")) #split table into two groups with two locations
figCap_plotTitle <- "Percentage of Polk, Norman, Mahnomen County\nChildren Ages 24−35 Months for DTap, Hep A, Hep B, Hib, & MMR"
figSubcap <- "Data Source: @mdhPHDAPImmuizations"
plotXCaption <- paste("Data Source:",mdhPHDAPImmuizations) #Since the x axis is passed into plotly, I am defining the x axis for the plot with the data source so when/if people use the plot in their work the data source is referenced ggplot does a a caption argument but it does not pass into plotly. If the caption should be after the legend, then ggplot caption can be used for the pdf version and annotation can be used in plotly, I'll just have to pass an extra argument into the plotly function.
filtered_data <- f_pHDAPImmunization |>
dplyr::filter(vaccine %in% c(vaccine %in% c("PCV", "Polio", "Rotavirus", "Varicella"))) |>
dplyr::group_by(location, fips) |>
dplyr::mutate(#Passed into ggplot (PDF Plot) but displayed in plotly (HMTL Plot)
toolTipTextHeader1 = "Year: "
, toolTipTextValue1 = year
, toolTipTextHeader2 = "\nLocation: "
, toolTipTextValue2 = location
, toolTipTextHeader3 = "\nVaccine Percentage: "
, toolTipTextValue3 = scales::label_percent(accuracy= 0.01)(percent)
) |>
dplyr::ungroup()
minYr <- unique(min(filtered_data$year))
maxYr <- unique(max(filtered_data$year))
# Filtering data here handles table variations better and is easier to maintain than filtering in the function.
filtered_dataTbl <- filtered_data |>
dplyr::filter(year >= maxYr-1)  |>
dplyr::arrange(fips, vaccine, year) |>
dplyr::mutate(placeholder = scales::label_percent(accuracy= 0.01)(percent)) |>  #I wanted to use formattable but DT strips format when converted to HTML Table
dplyr::group_by(fips, vaccine) |>
dplyr::mutate(percentageChange = dplyr::case_when(
year == maxYr ~ scales::label_percent(accuracy= 0.01)((percent) - dplyr::first(percent)) #Since there is only 2, most recent - next
, TRUE ~ ""
)
, percentageChange = ifelse(is.na(percentageChange), "--", percentageChange)
) |>
dplyr::ungroup() |>
dplyr::select(year, location, vaccine, placeholder, percentageChange) # Ensure fields are ordered as desired.
#split table into two groups for pdf output
filtered_dataTblMM <- filtered_dataTbl |>
dplyr::filter(location %in% c("Minnesota", "Mahnomen"))  # two locations
filtered_dataTblNP <- filtered_dataTbl |>
dplyr::filter(location %in% c("Norman", "Polk")) #split table into two groups with two locations
